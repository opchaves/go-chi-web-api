// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: transactions.sql

package model

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createTransaction = `-- name: CreateTransaction :one
INSERT INTO transactions (
  title,
  "note",
  amount,
  paid,
  t_type,
  handled_at,
  workspace_id,
  user_id,
  category_id,
  account_id
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
) RETURNING id, title, note, amount, paid, t_type, workspace_id, user_id, category_id, account_id, handled_at, created_at, updated_at
`

type CreateTransactionParams struct {
	Title       string           `json:"title"`
	Note        *string          `json:"note"`
	Amount      pgtype.Numeric   `json:"amount"`
	Paid        bool             `json:"paid"`
	TType       string           `json:"t_type"`
	HandledAt   pgtype.Timestamp `json:"handled_at"`
	WorkspaceID uuid.UUID        `json:"workspace_id"`
	UserID      uuid.UUID        `json:"user_id"`
	CategoryID  uuid.UUID        `json:"category_id"`
	AccountID   uuid.UUID        `json:"account_id"`
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (*Transaction, error) {
	row := q.db.QueryRow(ctx, createTransaction,
		arg.Title,
		arg.Note,
		arg.Amount,
		arg.Paid,
		arg.TType,
		arg.HandledAt,
		arg.WorkspaceID,
		arg.UserID,
		arg.CategoryID,
		arg.AccountID,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Note,
		&i.Amount,
		&i.Paid,
		&i.TType,
		&i.WorkspaceID,
		&i.UserID,
		&i.CategoryID,
		&i.AccountID,
		&i.HandledAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const deleteTransaction = `-- name: DeleteTransaction :exec
DELETE FROM transactions WHERE id = $1 and user_id = $2
`

type DeleteTransactionParams struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) DeleteTransaction(ctx context.Context, arg DeleteTransactionParams) error {
	_, err := q.db.Exec(ctx, deleteTransaction, arg.ID, arg.UserID)
	return err
}

const getTransactionById = `-- name: GetTransactionById :one
SELECT id, title, note, amount, paid, t_type, workspace_id, user_id, category_id, account_id, handled_at, created_at, updated_at FROM transactions WHERE id = $1 and user_id = $2
`

type GetTransactionByIdParams struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) GetTransactionById(ctx context.Context, arg GetTransactionByIdParams) (*Transaction, error) {
	row := q.db.QueryRow(ctx, getTransactionById, arg.ID, arg.UserID)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Note,
		&i.Amount,
		&i.Paid,
		&i.TType,
		&i.WorkspaceID,
		&i.UserID,
		&i.CategoryID,
		&i.AccountID,
		&i.HandledAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getTransactionsByUser = `-- name: GetTransactionsByUser :many
SELECT id, title, note, amount, paid, t_type, workspace_id, user_id, category_id, account_id, handled_at, created_at, updated_at FROM transactions WHERE user_id = $1
`

func (q *Queries) GetTransactionsByUser(ctx context.Context, userID uuid.UUID) ([]*Transaction, error) {
	rows, err := q.db.Query(ctx, getTransactionsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Note,
			&i.Amount,
			&i.Paid,
			&i.TType,
			&i.WorkspaceID,
			&i.UserID,
			&i.CategoryID,
			&i.AccountID,
			&i.HandledAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTransaction = `-- name: UpdateTransaction :one
UPDATE transactions SET
  title = coalesce($1, title),
  "note" = coalesce($2, "note"),
  amount = coalesce($3, amount),
  paid = coalesce($4, paid),
  t_type = coalesce($5, t_type),
  handled_at = coalesce($6, handled_at),
  category_id = coalesce($7, category_id),
  account_id = coalesce($8, account_id)
WHERE id = $9 and user_id = $10 RETURNING id, title, note, amount, paid, t_type, workspace_id, user_id, category_id, account_id, handled_at, created_at, updated_at
`

type UpdateTransactionParams struct {
	Title      *string          `json:"title"`
	Note       *string          `json:"note"`
	Amount     pgtype.Numeric   `json:"amount"`
	Paid       *bool            `json:"paid"`
	TType      *string          `json:"t_type"`
	HandledAt  pgtype.Timestamp `json:"handled_at"`
	CategoryID uuid.NullUUID    `json:"category_id"`
	AccountID  uuid.NullUUID    `json:"account_id"`
	ID         uuid.UUID        `json:"id"`
	UserID     uuid.UUID        `json:"user_id"`
}

func (q *Queries) UpdateTransaction(ctx context.Context, arg UpdateTransactionParams) (*Transaction, error) {
	row := q.db.QueryRow(ctx, updateTransaction,
		arg.Title,
		arg.Note,
		arg.Amount,
		arg.Paid,
		arg.TType,
		arg.HandledAt,
		arg.CategoryID,
		arg.AccountID,
		arg.ID,
		arg.UserID,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Note,
		&i.Amount,
		&i.Paid,
		&i.TType,
		&i.WorkspaceID,
		&i.UserID,
		&i.CategoryID,
		&i.AccountID,
		&i.HandledAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
